# Fast Refresh

Fast Refresh는 React 컴포넌트의 변경 사항에 대해서 거의 즉각적인 피드백을 받을 수 있게 해주는 React Native 기능입니다. Fast Refresh는 기본적으로 활성화되어 있으며, React Naitve 개발자 메뉴에서 "Fast Refresh 활성화"를 선택해 활성화 또는 비활성화 할 수 있습니다. Fast Refresh를 사용하면 대부분의 편집 내용이 1~2초 내에 반영됩니다. 

## 작동 방식

- React 컴포넌트만 내보내는 모듈을 편집하는 경우, Fast Refresh는 해당 모듈에 대해서만 코드를 업데이트하고 컴포넌트를 다시 렌더링합니다. 스타일, 렌더링 로직, 이벤트 핸들러, 효과 등 해당 파일의 모든 항목을 편집할 수 있습니다. 
- React 컴포넌트가 아닌 항목을 내보내는 모듈을 편집하는 경우, Fast Refresh는 해당 모듈과, 해당 모듈을 가져오는 다른 모듈들을 전부 다시 실행합니다. 따라서 `Button.js` 와 `Modal.js` 가 `Theme.js` 를 import하고 있다면, `Theme.js` 를 편집했을 때 두 컴포넌트( `Button.js`, `Modal.js` )가 모두 업데이트됩니다. 
- 마지막으로, **React 트리 외부에 있는 모듈에서 import되는 파일을 편집**하는 경우, Fast Refresh는 **전체 리로드를 수행**합니다. React 컴포넌트를 렌더링하지만, **React 컴포넌트가 아닌 컴포넌트**에서 가져온 값을 내보내는 파일이 있을 수도 있습니다. 예를 들어, 컴포넌트가 상수를 내보내고, React가 아닌 유틸리티 모듈이 이 상수를 가져온다고 합시다. 이 경우 쿼리를 별도의 파일로 마이그레이션하고 이를 두 파일로 가져오는 것이 좋습니다. 이렇게 하면 Fast Refresh가 다시 활성화됩니다. 다른 경우들도 대부분 비슷한 방법으로 해결할 수 있습니다. 

## 에러 복구

Fast Refresh 세션 중에 **문법 오류**가 있으면, 이를 수정한 후 파일을 다시 저장할 수 있습니다. 그러면 빨간 상자가 사라집니다. 문법 오류가 있는 모듈들은 실행되지 않기 때문에 앱을 다시 로드할 필요가 없습니다. 

모듈 초기화 중에 런타임 에러가 발생한 경우 (예를 들어, `StyleSheet.create` 대신 `Style.create` 를 입력한 경우), Fast Refresh 세션은 에러를 고친 후에 다시 진행됩니다. 에러를 고치면 빨간 상자가 사라지고 모듈은 업데이트됩니다. 

오류가 발생하여 컴포넌트 내에서 런타임 에러가 발생하는 경우에도, Fast Refresh 세션은 마찬가지로 오류를 고친 후에 계속 진행됩니다. 이 경우 React는 업데이트된 코드를 사용해 애플리케이션을 다시 마운트합니다. 

엡에 [에러 바운더리](https://reactjs.org/docs/error-boundaries.html)(배포에서의 실패에 대비하는 데 좋은 방법)가 있으면, 에러 박스(빨간색 박스) 이후 편집에서 렌더링을 다시 시도합니다. 그런 의미에서 에러 바운더리가 있으면, 루트 앱 화면으로 매번 튕겨나가는 것을 방지할 수 있습니다. 그러나, 에러 바운더리가 너무 세분화되어서는 안 됩니다. 에러 바운더리는 React 배포에서 사용되며, 항상 의도적으로 설계되어야 합니다. 

## 한계점

Fast Refresh는 편집 중인 컴포넌트에서 로컬 React state를 유지합니다. 단, 해당 state를 유지하는 것이 안전한 경우에만 그렇게 합니다. 파일을 편집할 때마다 로컬 state가 리셋되는 데에는 몇 가지 이유가 있습니다. 

- 클래스 컴포넌트에서는 로컬 state를 보존하지 않습니다. (함수 컴포넌트와 Hooks에서만 state를 보존합니다). 
- 편집 중인 모듈이 React 컴포넌트 외에 추가적으로 내보내는 요소들을 가지고 있을 수 있습니다. 
- 모듈이 `createNavigationContainer(MyScreen)`와 같은 고차 컴포넌트를 호출한 결과를 내보내기도 합니다. 반환된 컴포넌트가 클래스인 경우, state는 리셋됩니다. 

장기적으로는, 코드가 함수 컴포넌트와 Hooks 기반으로 많이 옮겨갈수록, state가 보존되는 경우가 더 많아질 것입니다. 

## 팁

- Fast Refresh는 함수 컴포넌트 (그리고 Hooks)에서 기본적으로 React 로컬 state를 보존합니다. 
- 때때로 state가 리셋되고, 컴포넌트가 다시 마운트되도록 강제해야 하는 경우가 있습니다. 이러한 경우  `// @refresh reset` 을 편집 중인 파일의 아무 곳에나 추가하면 됩니다. 이 지시문은 파일의 로컬이며, Fast Refresh가 파일을 편집할 때마다 해당 파일에 정의된 컴포넌트들을 다시 마운트하도록 지시합니다. 예를 들어 마운트에서만 발생하는 애니메이션을 수정해야하는 경우에 이 기능을 유용하게 사용할 수 있습니다. 

## Fast Refresh와 Hooks

Fast Refresh는 편집 사이에 컴포넌트의 state를 가능하면 유지하려고 합니다. 특히 `useState` 와 `useRef` 는 Hooks 호출의 순서나 인자를 변경하지 않는 이상 이전 값을 유지합니다. 

`useEffect`, `useMemo`, `useCallback` 과 같이 종속성이 있는 Hooks는 Fast Refresh 중에 *항상* 업데이트됩니다. Fast Refresh가 발생하는 동안 이들의 종속성 목록은 무시됩니다. 

예를 들어  `useMemo(() => x * 2, [x])` 를  `useMemo(() => x * 10, [x])` 로 수정하는 경우, `x` (종속성)가 바뀌지 않았다고 하더라도 다시 실행됩니다. React에서 그렇게 하지 않으면 수정사항이 화면에 반영되지 않기 때문입니다. 

때로는 이것이 예상치 못한 결과로 이어질 수 있습니다. 예를 들어 종속성 배열이 비어 있는 `useEffect` 도 Fast Refresh 중에 한 번 다시 실행됩니다. 그러나, Fast Refresh 없이도 `useEffect` 를 가끔씩 다시 실행할 때 복원력이 있는 코드를 작성하는 것은 좋은 습관입니다. 나중에 새로운 종속성을 더 쉽게 도입할 수 있게 해주기 때문입니다. 