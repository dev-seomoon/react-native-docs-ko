# 테스트

코드베이스가 확장되면서, 예상치 못한 작은 오류와 에지 케이스들이 더 큰 장애로 이어질 수 있습니다. 버그는 사용자 경험을 악화시켜 결과적으로 비즈니스 손실로 이어집니다. 취약한 프로그래밍을 방지하는 한 가지 방법은, 코드를 내놓기 전에 먼저 테스트하는 것입니다.

이 가이드에서는 정적 분석에서부터 엔드 투 엔드 테스트까지, 앱이 예상대로 작동되는지 확인할 수 있는 여러 가지 자동화된 방식들을 다룹니다.

![Testing is a cycle of fixing, testing, and either passing to release or failing back into testing.](https://user-images.githubusercontent.com/52448114/120095656-05037300-c162-11eb-89f6-2f3e8a2caa91.png)

## 테스트를 해야 하는 이유

우리는 인간이고, 인간은 실수를 합니다. 테스트는 이러한 오류를 발견하고 코드가 작동하는지 확인하는 데에 도움이 되기 때문에 중요합니다. 더욱 중요한 것은, 테스트를 통해 나중에 새로운 기능을 추가하거나, 기존 기능을 리팩토링하거나, 프로젝트의 주요 종속성을 업그레이드하더라도 코드가 잘 작동되도록 할 수 있다는 점입니다.

테스트를 하는 것에는 생각보다 많은 가치가 있습니다. 코드에서 버그를 고치는 가장 좋은 방법 중 하나는 버그를 노출시키는 실패 테스트 케이스를 작성하는 것입니다. 그런 다음 버그를 수정하고 테스트를 다시 실행할 때, 테스트를 통과하면 버그가 수정되었음을 의미하며, 코드 베이스에 다시 들어가지 않습니다.

또한 테스트는 팀에 새롭게 합류하는 사람들을 위한 문서로서의 역할도 할 수 있습니다. 코드베이스를 한 번도 본 적이 없는 사람들에게 있어서, 테스트를 읽어보는 것은 코드의 작동 방식을 이해하는 데에 도움이 될 수 있습니다.

마지막으로, 보다 자동화된 테스트를 통해 수동 QA에 소요되는 시간이 줄어들어 귀중한 시간을 확보할 수 있습니다.

## 정적 분석

코드 품질을 향상시키는 첫 번째 단계는 정적 분석 도구를 사용하는 것입니다. 정적 분석은 코드를 실행하지 않고, 코드를 작성하는 단계에 오류를 검사합니다.

- **Linters** 는 unused code와 같은 일반적인 오류를 잡아내기 위해서, 함정을 피하기 위해서, 그리고 공백 대신 탭을 사용하는 것과 같이 (또는 설정에 따라 반대로) 금지된 스타일 가이드를 표시하기 위해서 코드를 분석합니다.

- **타입 체킹** 은 함수가 설계된 의도에 맞는 인자를 전달받도록 합니다. 예를 들어 숫자를 전달받을 것으로 예상되는 카운팅 함수에 문자열을 전달하는 일을 방지합니다.

React Native는 linting을 위한 도구로 [ESLint](https://eslint.org/) , 타입 체킹을 위한 도구로 [Flow](https://flow.org/en/docs/)를 같이 제공합니다. 일반 JavaScript로 컴파일되는 타입형 언어인 [TypeScript](https://reactnative.dev/docs/typescript)를 사용할 수도 있습니다.

## 테스트가 가능한 코드 작성하기

테스트를 시작하려면, 먼저 테스트가 가능한 코드를 작성해야 합니다. 비행기 제조과정을 떠올려보세요. 모델이 최초로 출시되기 전에, 모든 복잡한 시스템이 함께 잘 작동되며, 개별 부품이 안전하고 올바르게 기능함을 보장하기 위해 테스트됩니다. 예를 들어 날개는 극한의 하중으로 구부리고, 엔진 부품은 내구성을 시험하며, 전면 유리는 조류와의 충돌 시뮬레이션을 통해 테스트합니다.

소프트웨어도 비슷합니다. 여러 줄로 이루어진 하나의 큰 파일로 프로그램 전체를 작성하는 대신에, 여러 개의 작은 모듈로 코드를 작성해서, 전체를 테스트하는 것보다 더 철저하게 테스트할 수 있도록 합니다. 이러한 방식으로, 테스트 가능한 코드를 작성하는 것은 클린한, 모듈화된 코드를 작성하는 것과 관련되어 있습니다.

앱을 좀 더 테스트가 용이하게 만들려면, 앱의 뷰 부분(React 컴포넌트)을 비즈니스 로직과 앱의 상태(Redux, MobX 또는 다른 솔루션 사용 여부에 관계 없이)로부터 분리하는 것에서 시작합니다. 이렇게 하면, React 컴포넌트에 의존해서는 안 되는 비즈니스 로직 테스트를, 앱의 UI를 렌더링하는 것이 주된 역할인 컴포넌트와 독립적으로 유지할 수 있습니다!

이론적으로는 컴포넌트에서 가져오는 모든 로직과 데이터를 옮기는 것까지 생각해볼 수 있습니다. 이렇게 하면 컴포넌트는 온전히 렌더링만 하게 됩니다. state는 컴포넌트로부터 완전히 독립됩니다. 앱의 로직은 어떠한 React 컴포넌트도 없이 작동할 수 있습니다!

> 다른 학습 자료를 통해 테스트 가능한 코드에 대해 더 자세히 살펴보기를 권장합니다.

## 테스트 작성하기

테스트 가능한 코드를 작성했다면, 이제 실제 테스트를 작성해봅시다. React Native의 기본 템플릿은 [Jest](https://jestjs.io/) 테스트 프레임워크와 같이 제공됩니다. 이 프레임워크는 React Native 환경에 맞게 조정된 사전 설정(프리셋)을 가지고 있어서, 설정이나 mocks를 수정하지 않고도 바로 생산적으로 사용할 수 있습니다 ([mocks에 대해 더 알아보기](https://reactnative.dev/docs/testing-overview)). Jest를 사용해 이 가이드에서 다루는 모든 유형의 테스트를 작성할 수 있습니다.

> 테스트 주도 개발을 하는 경우, 실제로 테스트를 먼저 작성하게 되어서, 코드의 테스트 가능성이 보장됩니다.

### 테스트 작성하기

테스트는 짧아야 하며 이상적으로는 한 가지만 테스트해야 합니다. Jest로 작성된 단위 테스트 예제로 시작해봅시다.

```jsx
it("given a date in the past, colorForDueDate() returns red", () => {
  expect(colorForDueDate("2000-10-20")).toBe("red");
});
```

테스트는 [`it`](https://jestjs.io/docs/en/api#testname-fn-timeout))) 함수에 전달된 문자열로 설명됩니다. 테스트 대상이 무엇인지 분명히 알 수 있도록 설명을 작성하는 데 세심한 주의를 기울이십시오. 다음 사항에 최선을 다하십시오.

1. **Given** - 전제 조건
2. **When** - 테스트 중인 함수에 의해 실행되는 작업
3. **Then** - 예상 결과

이를 AAA (Arrange, Act, Assert)라고도 합니다.

Jest는 테스트 구성을 돕는 describe 함수를 제공합니다. 하나의 기능에 속하는 모든 테스트를 그룹화하는 데에 `describe` 를 사용하십시오. Describe들은 필요한 경우 중첩시킬 수도 있습니다. 그 외에 일반적으로 사용하는 함수는 테스트 중인 객체를 셋팅하기 위해 사용할 수 있는 `beforeEach` 또는 `beforeAll` 입니다. [Jest api refrence](https://jestjs.io/docs/en/api) 에서 더 자세히 알아보세요.

테스트 단계가 많거나 기대 수준이 높은 경우, 여러 개의 작은 단계로 분할할 수 있습니다. 또한 테스트가 서로 완전히 독립되어 있는지 확인하십시오. 각 테스트는 다른 테스트를 먼저 실행하지 않고 자체적으로 실행할 수 있어야 합니다. 반대로, 모든 테스트를 함께 실행하는 경우, 첫 번째 테스트가 두 번째 테스트의 출력에 영향을 미치지 않아야 합니다.

마지막으로, 개발자로서 우리는 코드가 잘 작동하고 충돌하지 않는 것을 좋아합니다. 그러나 테스트를 할 때는, 실패한 테스트를 *좋은 기회*라고 생각할 필요가 있습니다. 테스트에 실패한다는 것은, 무언가 잘못되었다는 것을 의미합니다. 이는 문제가 사용자에게 영향을 미치기 전에 해결할 기회를 줍니다.

## 단위 테스트 (Unit Tests)

단위 테스트는 개별 함수 또는 클래스와 같은, 코드의 가장 작은 부분을 다룹니다.

When the object being tested has any dependencies, you’ll often need to mock them out, as described in the next paragraph.

테스트 대상 객체에 종속성이 있는 경우, 다음 단락에서 설명하는 대로 이를 모킹(moking)해야 할 때가 많습니다.

단위 테스트의 장점은, 빠르게 작성하고 실행할 수 있다는 점입니다. 따라서 작업을 하면서 테스트가 통과되고 있는지에 대한 피드백을 빠르게 받을 수 있습니다. Jest에는 편집 중인 코드와 관련된 테스트를 지속적으로 실행할 수 있는 옵션도 있습니다.

![ ](https://user-images.githubusercontent.com/52448114/120095688-3aa85c00-c162-11eb-9030-6341da278945.png)

### 모킹 (Mocking)

때때로, 테스트된 객체가 외부 종속성을 가지고 있는 경우, 이를 "mock out"해야할 수 있습니다. "모킹(Mocking)"은 코드의 일부 종속성을 사용자 자신의 구현으로 대체하는 것입니다.

> 일반적으로, 테스트에서 실제 객체를 사용하는 것이 mocks를 사용하는 것보다 낫지만, 그것이 불가능한 상황도 있습니다. (예: JS 단위 테스트가 Java나 Objective-C로 작성된 네이티브 모듈에 의존하는 경우)

여러분이 도시의 현재 날씨를 보여주는 앱을 작성하고 있고, 날씨 정보를 제공하는 외부 서비스나 다른 의존성을 사용한다고 상상해 보세요. 비가 내리는 경우 비구름과 함께 이미지를 보여주려고 합니다. 테스트에서 해당 서비스를 호출하지 않으려는 이유는 다음과 같습니다.

- (관련된 네트워크 요청으로 인해) 테스트가 느리고 불안정해질 수 있습니다.
- 테스트를 실행할 때마다 서비스가 다른 데이터를 반환할 수 있습니다.
- 테스트를 꼭 실행해야 할 때 서드 파티 서비스가 오프라인 상태가 될 수 있습니다.

따라서, 여러분은 수천 줄의 코드와 온라인 온도계를 효과적으로 대체하면서 서비스의 mock 구현을 제공할 수 있습니다!

> Jest는 기능 수준에서부터 모듈 수준까지의 [모킹에 대한 지원](https://jestjs.io/docs/en/mock-functions#mocking-modules)과 함께 제공됩니다.

## 통합 테스트 (Integration Tests)

큰 소프트웨어 시스템을 작성할 때, 작은 개별 소프트웨어들은 서로 상호작용해야 합니다. 단위 테스트에서 단위가 다른 단위에 의존하고 있는 경우, 결국 이를 가짜로 대체하면서 해당 종속성을 모킹해야할 수도 있습니다.

통합 테스트에서, 실제 개별 단위를 결합하고 (앱에서와 동일하게) 함께 테스트해 예상한대로 작동하는지 확인합니다. 이는 여기에서 모킹이 일어나지 않는다고 말하는 것이 아닙니다. 여전히 모킹이 필요할 것입니다(예를 들어 기상청과의 소통을 모킹하기 위해). 그러나 단위 테스트에서보다는 모킹이 훨씬 적게 필요할 것입니다.

> 통합 테스트가 의미하는 바가 무엇인지에 대해서 용어가 항상 일치하는 것은 아닙니다. 또한 단위 테스트와 통합 테스트의 구분이 항상 명확하지는 않을 수 있습니다. 이 가이드에서는 다음과 같은 경우가 "통합 테스트"에 해당됩니다.
>
> - 위에서 설명된 대로 여러 모듈을 조합하는 경우
> - 외부 시스템을 사용하는 경우
> - 다른 애플리케이션 (기상 서비스 API 등)에 대한 네트워크 호출을 하는 경우
> - 모든 종류의 파일 또는 데이터베이스 입출력(I/O)를 실행하는 경우

![ ](https://user-images.githubusercontent.com/52448114/120095690-3c721f80-c162-11eb-883e-cb26722e289d.png)

## 컴포넌트 테스트

React 컴포넌트는 앱을 렌더링하는 역할을 하며, 사용자는 출력된 컴포넌트와 직접적으로 상호작용 합니다. 앱의 비즈니스 로직이 높은 테스트 적용 범위를 가지고 있고 올바른 경우에도, 컴포넌트 테스트를 거치지 않으면 사용자에게 손상된 UI를 제공하게 될 수 있습니다. 컴포넌트 테스트는 단위 테스트와 통합 테스트 모두에 포함될 수 있지만, React Native의 핵심적인 부분이기 때문에 별도로 다루겠습니다.

React 컴포넌트를 테스트 하는 경우, 다음 두 가지를 테스트할 수 있습니다.

- 상호 작용: 사용자와 상호 작용할 때 컴포넌트가 올바르게 작동하는지 확인합니다. (예: 사용자가 버튼을 누를 때)
- 렌더링: React에서 사용되는 컴포넌트의 렌더링 결과가 올바른지 확인합니다. (예: 버튼의 모양 및 UI 내에서의 위치)

예를 들어, `onPress` 리스너를 가진 버튼이 있다면, 해당 버튼이 올바르게 표시되는지 여부와 버튼을 눌렀을 때 컴포넌트가 올바르게 처리되는지 여부를 테스트하려고 합니다.

이를 테스트하는 데 도움이 되는 몇 가지 라이브러리들이 있습니다.

- React 코어와 함께 개발된 React의 [Test Renderer](https://reactjs.org/docs/test-renderer.html)는 DOM이나 네이티브 모바일 환경에 의존하지 않고 순수 JavaScript 객체에 React 컴포넌트를 렌더링하는 데 사용할 수 있는 리액트 렌더러를 제공합니다.

- [React Native Testing Library](https://callstack.github.io/react-native-testing-library/)는 React의 테스트 렌더러 위에 구축되며, 다음 단락에서 설명할 `fireEvent`와 `query` API를 추가합니다.

> 컴포넌트 테스트는 Node.js 환경에서 실행되는 JavaScript 테스트에 불과합니다. 컴포넌트 테스트는 React Native 컴포넌트를 지원하는 iOS, Android 또는 다른 플랫폼 코드를 고려하지 않습니다. 따라서 모든 것이 사용자 입장에서 잘 작동할 것이라고 100% 확신할 수는 없습니다. iOS 또는 Android 코드에 버그가 있다면, 컴포넌트 테스트로는 이를 찾을 수 없을 것입니다.

![ ](https://user-images.githubusercontent.com/52448114/120095692-3da34c80-c162-11eb-9243-ba0ff29a5880.png)

### 사용자 상호작용 테스트

UI 렌더링 외에도, 컴포넌트는 `TextInput` 의 경우 `onChangeText` , `Button` 의 경우 `onPress` 와 같은 이벤트를 처리합니다. 또한 다른 함수나 이벤트 콜백을 포함할 수도 있습니다. 다음 예제를 참고하세요.

```jsx
function GroceryShoppingList() {
  const [groceryItem, setGroceryItem] = useState("");
  const [items, setItems] = useState([]);

  const addNewItemToShoppingList = useCallback(() => {
    setItems([groceryItem, ...items]);
    setGroceryItem("");
  }, [groceryItem, items]);

  return (
    <>
      <TextInput
        value={groceryItem}
        placeholder="Enter grocery item"
        onChangeText={(text) => setGroceryItem(text)}
      />
      <Button title="Add the item to list" onPress={addNewItemToShoppingList} />
      {items.map((item) => (
        <Text key={item}>{item}</Text>
      ))}
    </>
  );
}
```

사용자 상호 작용을 테스트 할 때, 사용자 관점에서 컴포넌트를 테스트하십시오. (페이지에는 어떤 내용이 있는지, 상호 작용했을 때 어떤 변화가 있는지 등)

일반적으로는, 사용자가 보거나 들을 수 있는 것을 사용하는 것을 선호합니다.

- 렌더링된 텍스트 또는 [접근성 도우미](https://reactnative.dev/docs/accessibility#accessibility-properties)를 사용하는 테스트

반대로, 다음을 피해야 합니다.

- 컴포넌트 props 또는 state에 대한 테스트
- 테스트ID 쿼리

props나 state와 같은 구현 세부 정보를 테스트하지 마십시오. 이러한 테스트는 사용자가 컴포넌트와 상호 작용하는 방식을 지향하지 않으며, 리팩토링에 의해 깨지는 경우가 있습니다 (예를 들어 일부 항목의 이름을 변경하거나 hooks를 사용해 클래스 컴포넌트를 다시 작성하는 경우).

> React 클래스 컴포넌트는 특히 내부 state, props 또는 이벤트 핸들러와 같은 구현 세부정보를 테스트하기 쉽습니다. 구현 세부 정보를 테스트하지 않으려면, Hooks와 함께 함수 컴포넌트를 사용하는 것이 좋습니다. 함수 컴포넌트는 컴포넌트 내부에 의존하기 어렵게 만듭니다.

[React Native Testing Library](https://callstack.github.io/react-native-testing-library/) 와 같은 컴포넌트 테스트 라이브러리는 제공된 API를 신중하게 선택함으로써 사용자 중심의 테스트를 작성할 수 있도록 지원합니다. 다음 예제에서는 사용자가 컴포넌트와 상호 작용하는 것을 시뮬레이션하는 `fireEvent` 메소드 `changeText` 와 `press` 를 사용하며, 렌더링 결과에서 일치하는 `Text` 노드를 찾는 `getAllByText` 쿼리 메소드를 사용합니다.

```jsx
test("given empty GroceryShoppingList, user can add an item to it", () => {
  const { getByPlaceholder, getByText, getAllByText } = render(
    <GroceryShoppingList />
  );

  fireEvent.changeText(getByPlaceholder("Enter grocery item"), "banana");
  fireEvent.press(getByText("Add the item to list"));

  const bananaElements = getAllByText("banana");
  expect(bananaElements).toHaveLength(1); // expect 'banana' to be on the list
});
```

이 예제는 함수를 호출할 때 state가 어떻게 변경되는지 테스트하지 않습니다. `TextInput` 에서 사용자가 텍스트를 변경하고, `Button` 을 누를 때 발생하는 작업을 테스트합니다!

### 렌더링된 결과 테스트

[Snapshot testing](https://jestjs.io/docs/en/snapshot-testing) 은 Jest에서 지원하는 고급 테스트입니다. 이는 매우 강력한 low-level의 도구이므로, 사용 시 각별한 주의가 필요합니다.

"컴포넌트 스냅샷"은 Jest에 내장된 사용자 지정 React serializer에 의해 생성되는, JSX와 유사한 문자열입니다. 이 serializer를 사용하면 Jest가 React 컴포넌트 트리를 사람이 읽을 수 있는 문자열로 변환해 줍니다. 다시 말해서, 컴포넌트 스냅샷은 테스트 실행 중에 생성되는 컴포넌트 렌더링 결과를 텍스트로 표현한 것입니다. 이는 다음과 같이 보일 수 있습니다.

```jsx
<Text
  style={
    Object {
      "fontSize": 20,
      "textAlign": "center",
    }
  }>
  Welcome to React Native!
</Text>
```

일반적으로 컴포넌트를 먼저 구현한 다음 스냅샷 테스트를 수행합니다. 그리고 스냅샷 테스트는 스냅샷을 생성하고 이를 저장소의 파일에 참조 스냅샷으로 저장합니다. **해당 파일은 코드 리뷰 시 확인되고 커밋됩니다.** 이후에 컴포넌트의 렌더링 결과물을 변경하면 스냅샷이 변경되어 테스트에 실패합니다. 테스트를 통과하려면 저장된 참조 스냅샷을 업데이트해야 합니다. 변경 사항은 그 후 다시 커밋되고 리뷰되어야 합니다.

스냅샷은 몇 가지 취약점을 가지고 있습니다.

- 개발자나 리뷰어의 경우, 스냅샷의 변경이 의도된 것인지 아니면 버그의 증거인지를 구별하기가 어려울 수 있습니다. 특히 규모가 큰 스냅샷은 빠르게 이해하기 어렵고, 추가된 가치가 낮아질 수 있습니다.
- 스냅샷 생성 시, 렌더링 결과물이 실제로는 잘못된 경우에도 해당 스냅샷은 올바른 것으로 간주됩니다.
- 스냅샷이 실패한 경우, 변경 예상 여부를 조사하지 않고 jest 옵션 `--updateSnapshot` 을 사용해 이를 업데이트할 수 있ㅅ브니다. 따라서 특정한 개발 규칙이 필요합니다.

스냅샷 자체는 컴포넌트 렌더링 로직이 올바른지 보장해주지 않습니다. 단지 예기치 않은 변경을 방지하고, 테스트 대상인 React 트리의 컴포넌트가 예상된 props (style 등) 를 받는지 확인할 뿐입니다

작은 스냅샷만 사용하기를 권장합니다 ([no-large-snapshots rule](https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/no-large-snapshots.md) 참고). 두 개의 React 컴포넌트 state 간의 변경 사항을 테스트하고 싶다면, [snapshot-diff](https://github.com/jest-community/snapshot-diff) 를 사용하십시오. 이러한 툴에 의구심이 든다면 이전 단락에서 설명한 명시적 기대를 사용하는 것도 좋습니다.

![ ](https://user-images.githubusercontent.com/52448114/120095698-44ca5a80-c162-11eb-8939-97ca9a9c6f11.png)

## 엔드 투 엔드 테스트 (End-to-End Tests)

엔드 투 엔드 (E2E) 테스트에서는 사용자 관점에서, 앱이 디바이스에서 (또는 시뮬레이터 / 에뮬레이터에서) 예상대로 작동하는지 확인합니다.

이는 릴리즈 설정에서 앱을 구축하고 그에 대한 테스트를 실행함으로써 수행됩니다. E2E 테스트에서는 React 컴포넌트, React Native API, Redux stores, 또는 어떠한 비즈니스 로직에 대해서도 더 이상 고려하지 않습니다. 이는 E2E 테스트의 목적이 아니며, E2E 테스트 중에 접근도 불가능합니다.

대신에 E2E 테스트 라이브러리는 앱의 화면에 있는 엘리먼트를 찾고 제어할 수 있게 해줍니다. 예를 들어, 실제 사용자와 같은 방식으로 _실제로_ 버튼을 누르거나 `TextInput` 에 텍스트를 삽입합니다. 그런 다음 앱의 화면에 특정한 엘리먼트가 존재하는지 여부, 표시되는지 여부, 어떤 텍스트가 포함되어 있는지 등에 대해 확인할 수 있습니다.

E2E 테스트는 앱의 작동에 대해 가장 높은 신뢰도를 주는 테스트입니다. 그러나 다음과 같은 단점도 있습니다.

- 다른 유형의 테스트에 비해 작성 시간이 더 많이 소요됩니다.
- 실행 속도가 느립니다.
- 다른 테스트에 비해 flaky한 경향이 있습니다. ("flaky" 테스트는 코드를 변경하지 않고 무작위로 통과하거나 실패하는 테스트입니다. )

E2E 테스트로 인증 흐름, 핵심 기능, 결제 등 앱의 중요한 부분을 다루십시오. 앱의 중요하지 않은 부분에 대해서는 더 빠른 JS 테스트를 사용합니다. 더 많은 테스트를 추가할수록 신뢰도는 높아지지만, 동시에 유지 및 실행에 더 많은 시간이 소요됩니다. 장단점을 고려하여 최선의 선택을 하십시오.

사용 가능한 E2E 테스트 도구가 몇 가지 있습니다. React Native 커뮤니티에서, [Detox](https://github.com/wix/detox/)는 React Native 앱에 적합하기 때문에 널리 사용되는 프레임워크입니다. iOS 및 Android 앱 영역에서 또 다른 인기 있는 라이브러리는 [Appium](http://appium.io/)입니다.

![ ](https://user-images.githubusercontent.com/52448114/120095699-45fb8780-c162-11eb-9fb2-ab2b17d041e4.png)

## 요약

이 가이드를 즐겁게 읽었길 바라며, 배운 점이 있길 바랍니다. 앱을 테스트할 수 있는 방법은 여러 가지가 있습니다. 처음에는 무엇을 사용할지 결정하기 어려울 수 있지만, 일단 React Native 앱에 테스트를 추가하기 시작하면 문서의 내용을 더 잘 이해하게 될 것입니다. 지금 바로 시작하세요!

### 링크

- [React 테스트 개요](https://reactjs.org/docs/testing.html)
- [React Native 테스트 라이브러리](https://callstack.github.io/react-native-testing-library/)
- [Jest 문서](https://jestjs.io/docs/en/tutorial-react-native)
- [Detox](https://github.com/wix/detox/)
- [Appium](
